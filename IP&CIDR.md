# 들어가기 전에...

서브넷이 "왜" 필요한지를 이해하려면 IP 개념을 알아야 한다.
이에 서브넷을 공부하기에 앞서 IP 주소 형식에 대해 간단히 설명하고자 한다.

# 1. IP 주소
IP 주소 형식은 두가지가 있다.

1. 클래스 기반 주소(Classful addressing)
2. 클래스 없는 주소(Classless Inter-Domain Routing)
	- ~~가변 길이 서브넷 마스킹(VLSM)을 사용하여 IP 주소의 네트워크와 호스트 주소 비트 간의 비율을 변경함~~
	- ~~서브넷 마스크는 호스트 주소를 0으로 변환하여 IP 주소의 네트워크 주소 값을 반호나하는 식별자 집함~~

1990년대 초반까지만 해도 IP 주소는 클래스 기반 주소 지정 시스템을 사용하여 할당했다.
(== 현재는 안씀. 이유는 읽다보면 나옵니다.)

그럼 클래스 기반 주소와 클래스 없는 주소에 대해 알아보자.

## 1.1 클래스 기반 주소(Classful addressing)
클래스 기반 주소 IP는 A, B, C, D, E 클래스가 있다.
이중 D클래스는 멀티캐스용 주소이고 E클래스는 연구용 주소이므로 우리가 알아야 할 개념은 A, B, C 클래스이다.

A, B, C 클래스는 다음과 같이 네트워크 주소의 맨 앞부분을 보면 구별할 수 있다.

- A 클래스: 1.0.0.0     ~ 126.0.0.0
- B 클래스: 128.0.0.0 ~ 191.255.0.0
- C 클래스: 192.0.0.0 ~ 223.255.255.0

참고차 D, E 클래스까지 같이 정리해보면 다음과 같다.

| 클래스 | IP                           |
| ------ | ---------------------------- |
| A      | 1 ~ 126(127은 예비번호)      |
| B      | 128 ~ 191                    |
| C      | 192 ~ 223                    |
| D      | 224 ~ 239(멀티캐스트용 주소) |
| E      | 240 ~ 255(연구용 주소)       |

### Q: 그렇다면 어디가 네트워크 부분이고 어디가 호스트 부분일까?
A: 클래스에 따라 네트워크 부분과 호스트 부분이 나뉘게 된다!

- A 클래스: 앞의 8비트가 네트워크 부분, 나머지 24비트는 호스트 부분
	- 예시: 44.0.0.1에서 (44)는 네트워크 주소이고 (0.0.1)는 호스트 주소

- B 클래스: 앞의 16비트가 네트워크 부분, 나머지 16비트는 호스트 부분
	- 예시: 128.16.0.2에서 (128.16)는 네트워크 주소이고 (0.2)는 호스트 주소

- C 클래스: 앞의 24비트가 네트워크 부분, 나머지 8비트는 호스트 부분
	- 예시: 192.168.1.100에서 (192.168.1)는 네트워크 주소이고 (100)는 호스트 주소

그렇다면 A 클래스는 각 네트워크 마다 총 16,777,216개(256 * 256 * 256)의 호스트,
B 클래스는 65,536(256 * 256)개의 호스트, C 클래스는 256개의 호스트를 가질 수 있다.

### 클래스 기반 주소의 한계점
클래스 기반 주소 체계는 비효율적으로 IP 주소를 할당하게 되어 한계점이 있다.

즉 서브네팅의 유연성이 부족하다는 것인데, 클래스 별로 크기가 고정되어 있기 때문에 사용하지 않는 IP 주소가 낭비된다는 것이다.

예를 들어 300개 호스트가 있는 회사에 IP 주소를 할당하게 되면, C 클래스는 256개의 호스트로 사용할 수 없으니 B 클래스를 할당하게 되면 약 6만 5천(65,536 - 300) 개만큼의 IP가 할당되지 않은 채 낭비된다.

이러한 문제를 해결하기 위해 여러가지 대안이 대두되었다.
1. 클래스리스 IP 주소 체계
2. 서브네팅
3. 사설 IP 주소와 NAT
4. DHCP
5. IPv6 도입

본문에서는 1번과 2번에 대해 다룰 예정이다.

## 1.2. 클래스 없는 주소(Classless Inter-Domain Routing)
CIDR은 가변길이 서브넷 마스킹(VLSM)을 사용하여 IP 주소의 네트워크 호스트 주소 비트 간의 비율을 변경한다. 이로 인해 IP 주소 낭비를 방지할 수 있다.

VLSM, 비율 변경 등 말이 어렵게 느껴질 수도 있지만, 표기법을 찬찬히 살펴보면 전혀 어렵지 않다!
### CIDR 표기법
- IP address / prefix 형태로 나타낸다. 
- prefix의 범위는 0 ~ 32이며, 상위 고정 비트 또는 네트워크 파트를 의미한다.
- 고정되지 않은 하위 비트가 호스트 파트이며 범위 값을 가진다.

**예시)**
- 10.2.0.0/16
	- IP: 10.2.0.0
	- prefix: 16
	- 네트워크 파트: 10.2
	- 호스트 파트: 0.1 ~ 10.2.255.255

따라서 CIDR 블록이 가지는 IP 범위 개수 = 2 ^ (32 - prefix) 이며, 당연한 얘기지만 prefix가 작을 수록 IP 범위가 크다.
### 예제
52.38.8.4/32 
- 고정 비트: 32
- 가변 비트: 0
- 범위: 52.38.8.4

10.5.0.0/16
- 고정 비트: 16
- 가변 비트: 16
- 범위: 10.5.0.0 ~ 10.5.255.255

10.5.1.0/24
- 고정 비트: 24
- 가변 비트: 8
- 범위: 10.5.1.0 ~ 10.5.1.255

(예제는 8비트로 잘라서 비교적 계산이 쉬웠는데, 시간이 된다면 /20와 같이 8로 떨어지지 않는 주소로 연습해보는 것도 추천한다.)

그렇다면 아까와 같이 300개의 호스트를 할당해야 하는 상황에 CIDR 표기법을 활용하면 prefix를 어떻게 설정하면 될까?
답은...!
/23

## 1.3 정리
- IP 주소는 클래스 기반 주소와 클래스 없는 주소가 있다.
- 클래스 기반 주소
	- A ~ C 클래스에 따라 할당되는 네트워크 크기가 다르다.
	- 비효율적인 네트워크 할당 방식으로 현재 사용되지 않는다.
- 클래스 없는 주소
	- 클래스 기반 주소의 단점을 개선한 방식이다.
	- 네트워크는 고정되어 있으며, prefix에 따라 크기가 달라진다.
	- 예시: 10.2.0.0/24는 네트워크 파트가 24비트이고 호스트 파트가 8비트이다.
